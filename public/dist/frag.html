<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Water Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script type="importmap">
    {
      "imports": {
        "three": "./three.module.js"
      }
    }
  </script>

<div id="bg-scene" class="fixed inset-0 -z-10"></div>
  <script type="module">
import * as THREE from "three";
import {
    Water
} from "./frag.js";
let water, mesh, WGeo

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x20232a);

const clock = new THREE.Clock();

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.set(0, 20, 5);

const renderer = new THREE.WebGLRenderer({
    antialias: false,
    alpha: false,
    depth: true,
    stencil: false,
    powerPreference: "high-performance",
    logarithmicDepthBuffer: false,
    preserveDrawingBuffer: false
});

renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(0.8);
renderer.physicallyCorrectLights = false;
renderer.outputEncoding = THREE.LinearEncoding;
renderer.toneMapping = THREE.NoToneMapping;
renderer.info.autoReset = false;
renderer.shadowMap.enabled = false;
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('bg-scene').appendChild(renderer.domElement);

WGeo = new THREE.PlaneGeometry(3000, 3000);

water = new Water(
    WGeo, {
        textureWidth: 128,
        textureHeight: 128,
        waterNormals: new THREE.TextureLoader().load('./water.jpg', function(texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        }),
        sunDirection: new THREE.Vector3(),
        sunColor: 0xffffff,
        waterColor: 0x001e0f,
        distortionScale: 4,
        fog: scene.fog !== undefined
    }
);

water.rotation.x = -Math.PI / 2;
water.position.y = -2

scene.add(water);

const uni = water.material.uniforms;
uni['size'].value = 2

const radius = 480;
const height = 150;
const cylGeo = new THREE.CylinderGeometry(radius, radius, height, 64, 1, false);

const cm = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
        topColor: {
            value: new THREE.Color(0xBBE8FF)
        },
        middleColor: {
            value: new THREE.Color(0xCCEEFF)
        },
        bottomColor: {
            value: new THREE.Color(0xffffff)
        },
        height: {
            value: height
        }
    },
    vertexShader: `
                varying float vY;
                void main() {
                    vY = position.y;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
    fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 middleColor;
                uniform vec3 bottomColor;
                uniform float height;
                varying float vY;
        
                void main() {
                    float f = (vY + height/2.0) / height; // 0 at bottom, 1 at top

                    float bottomToMiddle = smoothstep(0.0, 0.99, f);
                    float middleToTop = smoothstep(0.33, 2.0, f);
        
                    vec3 color = mix(bottomColor, middleColor, bottomToMiddle);
                    color = mix(color, topColor, middleToTop);
        
                    gl_FragColor = vec4(color, 1.0);
                }
            `
});

const boundary = new THREE.Mesh(cylGeo, cm);
boundary.position.y = height / 2 - 2.6;
scene.add(boundary);

boundary.renderOrder = 5;

const ambient = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambient);

const dir = new THREE.DirectionalLight(0xffffff, 1.5);
dir.position.set(100, 200, 100);
dir.castShadow = true;
scene.add(dir);

const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
scene.add(hemi);

scene.fog = new THREE.Fog(0xffffff, 40, 350);

const Clayer = new THREE.Group();
const m = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.15,
    depthWrite: false,
    depthTest: true,
    roughness: 1,
    metalness: 0
});

for (let i = 0; i < 150; i++) {
    const p = 2 + Math.floor(Math.random() * 10);

    const g = new THREE.BoxGeometry(1, 1, 1);
    const cloud = new THREE.InstancedMesh(g, m, p);

    const temp = new THREE.Object3D();

    for (let j = 0; j < p; j++) {
        const w = 20 + Math.random() * 40;
        const h = 5 + Math.random() * 10;
        const d = 20 + Math.random() * 40;

        temp.position.set(
            (Math.random() - 0.5) * 60,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 60
        );
        temp.scale.set(w, h, d);
        temp.updateMatrix();

        cloud.setMatrixAt(j, temp.matrix);
    }

    const scale = 0.8 + Math.random() * 0.4;
    cloud.scale.set(scale, scale, scale);

    cloud.position.set(
        (Math.random() - 0.5) * 2000,
        90,
        (Math.random() - 0.5) * 2000
    );

    Clayer.add(cloud);
}

scene.add(Clayer);

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

function animate() {
    requestAnimationFrame(animate);

    boundary.position.x = camera.position.x;
    boundary.position.z = camera.position.z;

    const t = clock.getElapsedTime();

    const RX = 400;
    const RZ = 450;

    camera.position.x = Math.sin(t * 0.1) * RX + Math.sin(t * 0.27) * 50;
    camera.position.z = Math.cos(t * 0.07) * RZ + Math.cos(t * 0.21) * 70;
    camera.position.y = Math.max(5, 25 + Math.sin(t * 0.25) * 20);

    camera.rotation.x = 0;
    camera.rotation.z = 0;
    camera.rotation.y = Math.sin(t * 0.1) * 0.8;

    const TampPos = new THREE.Vector3();
    camera.getWorldPosition(TampPos);

    Clayer.position.x = TampPos.x;
    Clayer.position.z = TampPos.z;

    const MxDist = 1000;

    for (const cloud of Clayer.children) {
        const data = cloud.userData;

        if (!data.initialized) {
            Object.assign(data, {
                speedX: 0.02 + Math.random() * 0.06,
                speedZ: 0.01 + Math.random() * 0.03,
                floatOffset: Math.random() * Math.PI * 2,
                initialized: true
            });
        }


        cloud.position.x += data.speedX;
        cloud.position.z += data.speedZ;

        const wrap = (val, max) => ((val + max) % (2 * max)) - max;

        cloud.position.x = wrap(cloud.position.x, MxDist);
        cloud.position.z = wrap(cloud.position.z, MxDist);
    }
    renderer.render(scene, camera);
}

animate();
  </script>

</body>

</html>